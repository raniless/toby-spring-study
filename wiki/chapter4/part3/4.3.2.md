# 4.3.2 Converter와 Formatter
- PropertyEditor와 달리 Converter는 변환 과정에서 메소드가 한 번만 호출된다.
- 즉 변환 작업 중에 상태를 인스턴스 변수로 저장하지 않는다는 뜻이다. 그래서 멀티스레드 환경에서 안전하게 공유해서 쓸 수 있다.
- 당연히 스프링의 싱글톤 빈으로 등록해두고 모든 변환 작업이 필요한 오브젝트에서 DI 받아 사용할 수 있다.

## Converter
- Converter 메소드는 소스 타입에서 타깃 타입으로의 단방향 변환만 지원한다.
- 물론 소스와 타깃을 바꿔서 컨버터를 하나 더 만들면 양방향 변환이 가능해진다.
- Converter는 소스와 타깃의 타입을 임의로 지정할 수 있다.
- PropertyEditor처럼 한쪽이 스트링 타입의 문자열로 고정되어 있지 않다. 따라서 범용적으로 사용할 수 있는 컨버터를 정의할 수 있다.
- Converter 인터페이스는 다음과 같이 정의되어 있다. 제네릭스를 이용해 소스 타입과 타깃 타입을 미리 지정해둘 수 있다.
  따라서 컨버터 API를 사용할 때 지저분한 타입 캐스팅 코드를 사용하지 않아도 된다.
  ```java
  @FunctionalInterface
  public interface Converter<S, T> {
    @Nullable
    T convert(S var1);
  }
  ```
- convert() 메소드는 매우 단순하다. 소스 타입의 오브젝트를 받아서 타깃 타입으로 변환해주면 된다.
- 다음은 LevelPropertyEditor에서 처럼 Level 이늄 오브젝트를 스트링 타입으로 변환하는 컨버터다.
  ```java
  public class LevelToStringConverter implements Converter<Level, String> {
    @Override
    public String convert(Level level) {
      return String.valueOf(level.intValue());
    }
  }
  ```
- 반대로 스트링 타입 오브젝트를 Level 오브젝트로 변환하는 컨버터도 다음과 같이 만들 수 있다.
  ```java
  public class StringToLevelConverter implements Converter<String, Level> {
    @Override
    public Level convert(String text) {
      return Level.valueOf(Integer.parseInt(text));
    }
  }
  ```
- 이 두 개의 컨버터를 함께 사용하면 LevelPropertyEditor와 동일한 기능을 하며, 멀티스레드 환경에서도 안전하게 사용할 수 있는 변경 기능을 제공할 수 있다.

## ConversionService
- 컨트롤러의 바인딩 작업에도 이렇게 만든 컨버터를 적용할 수 있을까? 물론 가능하다.
  하지만 PropertyEditor 처럼 Converter 타입의 컨버터를 개별적으로 추가하는 대신 ConversionService 타입의 오브젝트를 통해 WebDataBinder에 설정해줘야 한다.
- ConversionService는 여러 종류의 컨버터를 이용해서 하나 이상의 타입 변환 서비스를 제공해주는 오브젝트를 만들 때 사용하는 인터페이스다.
- 보통 ConversionService를 구현한 GenericConversionService는 스프링의 다양한 타입 변환 기능을 가진 오브젝트를
  등록 할 수 있는 ConverterRegistry 인터페이스도 구현하고 있다.
- 스프링 3.0에 추가된 새로운 타입 변환 오브젝트는 이미 살펴본 Converter 외에도 GenericConverter와 ConverterFactory를 이용해서도 만들 수 있다.
- GenericConverter를 이용하면 하나 이상의 소스-타깃 타입 변환을 한 번에 처리할 수 있는 컨버터를 만들 수 있다.
- 또 필드 컨텍스트를 제공받을 수 있다. 필드 컨텍스트는 모델의 프로퍼티에 대한 바인딩 작업을 할 때 제공받을 수 있는 메타정보를 말한다.
- 이 메타정보는 단순히 오브젝트의 타입뿐 아니라 클래스의 필드에 부여되어 있는 애노테이션, 제네릭스 타입 파라미터, 변환 대상인 메소드 파라미터 정보 등을 말한다.
- 따라서 GenericConverter를 이용하면 단순히 타입의 종류뿐 아니라 이런 부가적인 정보를 활용한 변환 로직을 작성할 수 있다.
- ConverterFactory는 제네릭스를 활용해서 특정 타입에 대한 컨버터 오브젝트를 만들어주는 팩토리를 구현할 때 사용한다.
- GenericConversionService는 일반적으로 빈으로 등록하고 필요한 컨트롤러에서 DI받아서 @InitBinder 메소드를 통해 WebDataBinder에 설정하는 방식으로 사용한다.
- Converter와 같은 새로운 타입 변환 오브젝트는 모두 멀티스레드에 동시 접근이 허용되는 안정성이 보장되므로 프로퍼티 에디터처럼 매번 오브젝트를 만들 필요가 없다.
- 따라서 다양한 타입 변환 오브젝트를 갖고 있는 ConversionService 오브젝트를 하나 정해두고 이를 모든 바인더에게 적용한다고 해도 성능 면에서 부담이 없다.
- @MVC 컨트롤러의 메소드 파라미터를 위해 사용하는 WebDataBinder에 GenericConversionService를 설정하는 방법은 두 가지가 있다.
  ### @InitBinder를 통한 수동 등록
  - 일부 컨트롤러에만 직접 구성한 ConversionService를 적용한다거나, 하나 이상의 ConversionService를 만들어두고 컨트롤러에 따라
    다른 변환 서비스를 선택하고 싶다면 컨트롤러의 @InitBinder 메소드를 통해 직접 원하는 ConversionService를 설정해줄 수 있다.
  - ConversionService와 그 안의 모든 타입 변환 오브젝트는 싱글톤으로 등록해서 사용해도 무방하므로 매번 new로 오브젝트를 만들어서
    등록할 필요는 없다. 대신 ConversionService를 빈으로 등록해두고 이를 컨트롤러가 DI 받아서 사용하도록 만들면 된다.
  - ConversionService에 직접 만든 컨버터 등의 변환 오브젝트를 추가하는 방법은 두 가지가 있다.
  - 첫 번째는 GenericConversionService를 상속해서 새로운 클래스를 만들고, 생성자에서 addConverter() 메소드를 이용해
    추가할 컨버터 오브젝트를 등록하는 방법이다. 이렇게 확장한 클래스를 빈으로 등록해서 사용한다.
  - 두 번째 방법은 추가할 컨버터 클래스를 빈으로 등록해두고 ConversionServiceFactoryBean을 이용해서 프로퍼티로 DI받은 컨버터들로 초기화된 GenericConversionService를 가져오는 방법이다.
    클래스를 새로 만드는 대신 설정만으로 사용할 컨버터를 관리할 수 있기 때문에 편리하다.
  - 두 번째 방법을 사용해보자. 다음과 같이 내부 빈으로 등록된 두 개의 컨버터를 converters 프로퍼티로 갖고 있는 ConversionServiceFactoryBean 빈을 등록한다.
    ```xml
    <bean class="org.springframework.context.support.ConversionServiceFactoryBean">
      <property name="converters">
        <set>
          <bean class="springbook...LevelToStringConverter" />
          <bean class="springbook...StringToLevelConverter" />
        </set>
      </property>
    </bean>
    ```
  - 컨트롤러에서는 다음과 같이 ConversionService 타입의 빈을 DI 받아두고 @InitBinder 메소드에서 WebDataBinder에 넣어주면 된다.
    ```java
    @Controller
    public class SearchController {
      @Autowired
      ConversionService conversionService;
    
      @InitBinder
      public void initBinder(WebDataBinder dataBinder) {
        dataBinder.setConversionService(this.conversionService);
      }
    }
    ```
  - 이렇게 해주면 ConversionServiceFactoryBean 빈을 통해 등록된 컨버터들이 모든 컨트롤러의 메소드 파라미터 바인딩에 사용될 것이다.
  - 매번 개별적으로 오브젝트를 만들어줘야 하는 프로퍼티 에디터와 달리, 컨버터를 비롯한 새로운 타입 변환 오브젝트는 싱글톤으로 사용 가능하기 때문에
    이렇게 하나의 ConversionService에 모두 등록해두고 한 번에 지정할 수 있다.
  - 아무리 많은 컨트롤러에서 사용한다고 하더라도 각 컨버터는 한 번만 만들어진다.
  - 물론 여러 개의 ConverionService를 만들어두고 컨트롤러마다 다르게 지정해도 상관 없다.
    WebDataBinder는 하나의 ConversionService 타입 오브젝트만 허용한다는 사실을 기억하고 있으면 된다.
  
  ### ConfigurableWebBindingInitializer를 이용한 일괄 등록
  - 어차피 컨버터는 싱글톤이라서 모든 컨트롤러의 WebDataBinder에 적용해도 별문제가 되지 않는다.
  - 따라서 귀찮게 DI와 @InitBinder 메소드를 사용해서 일일이 ConversionService를 지정해주는 대신 모든 컨트롤러에 한 번에 적용하는 방법도 있다.
  - 모든 컨트롤러에 적용하는 프로퍼티 데이터를 정의할 때 사용했던 WebBindingInitializer를 이용하면 된다.
  - WebBindingInitializer는 모든 컨트롤러에 일괄 적용되는 @InitBinder 메소드를 정의한 것이라고 볼 수 있다.
  - 프로퍼티 에디터의 경우처럼 WebBindingInitializer를 구현한 클래스를 만들고 이를 빈으로 등록해도 되지만,
    CoversionService를 적용할 때는 ConfigurableWebBindingInitializer를 사용하면 편리하다.
  - 코드를 따로 작성하지 않고 빈 설정만으로도 WebBindingInitializer 빈을 등록할 수 있기 때문이다.
  - 다음은 모든 컨트롤러에 적용할 변환 서비스를 등록해주는 XML 설정의 예이다.
  - ConversionService는 프로퍼티 에디터처럼 코드에서 new 키워드로 생성해줄 필요 없이 독립된 빈으로 등록할 수 있기 때문에
    DI로 가져온 ConversionService 빈을 WebDataBinder에 추가해주는 ConfigurableWebBindingInitializer를 만들 수 있는 것이다.
    ```xml
    <bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">
      <property name="webBindingInitializer" ref="webBindingInitializer" />
    </bean>
    
    <bean class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer">
      <property name="conversionService" ref="conversionService" />
    </bean>
    
    <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
      <property name="converters">
        ... <!-- 적용할 컨버터 빈 목록 -->
      </property>
    </bean>
    ```
  - 설정이 좀 많아져서 복잡해 보이지만, 이렇게만 해두면 컨트롤러에서 직접 ConversionService 타입 빈을 DI 받고 @InitBinder 메소드를
    이용해 바인더를 초기화하는 코드를 모두 제거할 수 있기 때문에 전체적으로 컨트롤러 코드를 단순하게 만들 수 있다는 장점이 있다.
  - 모든 컨트롤러에 일괄 적용하는 타입 변환 기능은 프로퍼티 에디터보다는 이렇게 컨버터와 같은 최신 타입 변환 기술을 사용하는 것이 좋다.
  - 컨버터 등록 때문에 복잡해진 XML 설정은 4장 후반부에 설명할 mvc 스키마 태그를 이용하면 간단하게 줄일 수 있으니 걱정할 것 없다.
  - ConversionServiceFactoryBean에서 자동으로 만들어주는 GenericConversionService에는 추가로 등록한 컨버터 말고도 기본으로
    등록된 여러가지 디폴트 컨버터가 있다.
  - 이 디폴트 컨버터는 @MVC의 파라미터 바인딩보다는 주로 애플리케이션 내에서의 일반적인 타입 변환 작업을 진행할 때 사용할 용도인
    것들이 대부분이니 크게 신경 쓰지 않아도 좋다.
  - 일반적인 타입 변환 서비스를 활용하고 싶다면 ConversionServiceFactory 클래스를 참고해서 디폴트로 등록되는 컨버터들이 어떤 것인지 살펴보기 바란다.

## Formatter와 FormattingConversionService

## 바인딩 기술의 적용 우선순위와 활용 전략