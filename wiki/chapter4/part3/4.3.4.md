# 4.3.4 Validator와 BindingResult, Errors
- @ModelAttribute로 지정된 모델 오브젝트의 바인딩 작업이 실패로 끝나느 경우는 두 가지가 있다.
- 하나는 타입 변환이 불가능한 경우고, 다른 한가지는 타입 변환은 성공했지만 검증기(validator)를 이용한 검사를 통과하지 못했기 때문이다.
- 스프링은 검증 과정에서 사용할 수 있는 Validator라는 이름의 표준 인터페이스를 제공한다.
- Validator를 통한 검증 과정의 결과는 BindingResult를 통해 확인할 수 있다.
- BindingResult는 Errors의 서브인터페이스다.
- Errors 인터페이스에는 바인딩 또는 검증 과정에서 오류를 발견하면 그에 대한 정보를 등록할 수 있는 메소드가 제공되고 있다.

## Validator
- 스프링의 Validator는 스프링에서 범용적으로 사용할 수 있는 오브젝트 검증기를 정의할 수 있는 API다.
- 물론 @Controller로 HTTP 요청을 @ModelAttribute 모델에 바인딩 할 때 주로 사용된다.
- 또는 비즈니스 로직에서 검증 로직을 분리하고 싶을 때도 사용할 수 있다.
- Validator 인터페이스는 다음과 같이 두 개의 메소드로 구성되어 있다.
  ```java
  package org.springframework.validation;

  public interface Validator {
    boolean supports(Class<?> clazz);

    void validate(Object target, Errors errors);
  }
  ```
- supports()는 이 검증기가 검증할 수 있는 오브젝트 타입인지를 확인해주는 메소드다.
  supports() 메소드를 통과한 경우에만 validate()가 호출된다. 바인딩이 완료된 오브젝트를 이용해 값을 검증하는 코드를 작성한다.
- Validator 이용해 검증한 결과, 아무 문제가 없다면 메소드를 정상 종료하면 된다.
- 만약 오류가 발견되면 Errors 인터페이스를 통해서 등록된 오류는 최종적으로 BindingResult에 담겨 컨트롤러에 전달된다.
- 검증 결과를 보고 컨트롤러는 그에 맞는 처리를 하고 뷰를 선택한다.
- 일반적으로 폼을 처리하는 컨트롤러 메소드라면 바인딩 또는 검증 과정에서 오류가 하나라도 발견되면 다시 폼을 띄워서 에러 메시지를 보여주고 재입력을 요구한다.
- 가장 대표적인 검증은 값을 입력했는지 확인하는 것이다.
- 사용자 입력 폼을 처리하는 컨트롤러 메소드에서 사용하 UserValidator를 만들어보자.
  모델 오브젝트는 User 타입이어야 한다. 따라서 supports() 메소드는 다음과 같이 만들면 된다.
  때로는 User의 서브클래스가 사용될 수도 있으므로 isAssignableFrom() 메소드를 사용하는 것이 좋다.
  ```java
  public boolean supports(Class<?> clazz) {
    return (User.class.isAssignableFrom(clazz));
  }
  ```
- 다음은 validate() 메소드를 만들 차례다. 파라미터로 전달되는 target 오브젝트는 결국 User 타입 오브젝트일 것이다.
  따라서 다음과 같이 User 타입으로 캐스팅한 후에 검증 작업을 진행해야 한다.
  ```java
  public void validate(Object target, Errors errors) {
    User user = (User)target;
  }
  ```
- 먼저 user의 getName()을 이용해 name 필드의 값이 입력됐는지 확인하자. 다음과 같이 null인 것과 빈 스트링인 것, 두 가지 모두 확인할 필요가 있다.
  입력값이 없다면, 이때는 errors의 rejectValue() 메소드를 호출해서 어떤 필드에 문제가 있는지 등록해줘야 한다.
  ```java
  if(User.getName() == null || user.getName().length() == 0) {
    errors.rejectValue("name", "field.required");
  }
  ```
- rejectValue() 메소드의 두 번째 파라미터는 에러 코드다. 에러 코드의 사용 방법은 뒤에서 다시 설명하겠다. 일단 에러 코드를 넣는다는 사실만 기억해두자.
- 스트링 타입의 프로퍼티 값을 매번 if문으로 체크하는 것은 번거롭다. 이럴땐 ValidationUtils의 유틸리티 메소드를 사용하면 편리하다.
  다음은 위의 if문장 전체와 동일한 기능을 하는 코드다.
  ```java
  ValidationUtils.rejectIfEmpty(errors, "name", "field.required");
  ```
- 공백문자도 허용하지 않으려면 rejectIfEmptyOrWhitespace() 메소드를 사용하면 된다.
- 0보다 작으면 안되는 age 필드가 있다고 해보자. 다음과 같이 검ㅈ믕코드를 추가한다.
  ```java
  if(user.getAge() < 0) {
    errors.rejectValue("name", "field.min", new Object[] {0}, null)
  }
  ```
- 여러 개의 필드 조건을 결합해서 검증하는 경우도 있다. 이때는 검증 과정에서 문제가 발견되더라도 특정 필드에 대한 오류로 만드는 것은 적당하지 않다.
- 이럴땐 필드 이름을 지정해야 하는 rejectValue() 대신 글로벌 에러를 추가할 수 있는 reject() 메소드를 사용하는 것이 적당하다.
- Validator는 보통 미리 정해진 단순 조건을 이용해 검증하는 데 사용된다. 필수 값의 입력 여부나 값의 범위, 길이, 형식 등이 주로 검증조건이 된다.
- 하지만 때로는 비즈니스 로직을 적용해서 값을 검증할 수도 있다. Validator는 싱글톤 빈으로 등록돼서 사용할 수 있다.
- 따라서 UserSerivce와 같은 빈을 이용해 비즈닐스 로직 관점에서 입력값을 검증하는 작업을 넣을 수 있다.
- 대표적인 예가 사용자 아이디가 이미 등록된 것인지 확인하는 경우다. 아이디 중복 문제는 서비스 계층을 거쳐 DAO까지 참여해야만 알 수 있다.
- Validator에서는 이런 길이나 형식 정도만 판단하고 아이디 중복 문제는 컨트롤러가 아니라 서비스 계층의 오브젝트에서 판단하게 할 수 있다.
- 이 경우 오류가 있다면 비즈니스 로직으로서의 의미가 있는 체크 예외나 특별한 리턴 값을 돌려주고, 이를 다시 컨트롤러가 확인해서 그에 따른 조치를 취하게 할 수도 있다.
- 검증 로직은 특정 계층에 종속되기보다는 도메인 오브젝트처럼 독립적으로 만드는 것이 좋다.
- 스프링의 validator를 구현한 검증 클래스를 도메인 오브젝트 단위로 만들고 이를 필요한 곳에서 호출해서 사용하거나,
  반대로 Validator에서 필요한 로직을 담고 있는 빈을 호출하는 것이 좋다.
- 다만 Validator를 써서 검증 작업을 진행하는 곳을 어디로 할지는 고민해봐야 한다.
- 스프링에서는 앞으로 설명할 네 가지 방법으로 Validator를 적용할 수 있다.
  ### 컨트롤러 메소드 내의 코드
  ### @Valid를 이용한 자동검증
  ### 서비스 계층 오브젝트에서의 검증
  ### 서비스 계층을 활용하는 Validator
  
## JSR-303 빈 검증 기능
## BindingResult와 MessageCodeResolver
## MessageSource