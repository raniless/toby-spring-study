# 4.3.3 WebDataBinder 설정 항목
## allowedFields, disallowedFields
- 스프링은 WebDataBinder 안에 바인딩이 허용된 필드 목록을 넣을 수 있는 allowedFields와 금지 필드 목록을
  넣을 수 있는 disallowedFields 프로퍼티를 설정할 수 있게 해준다.
- 전자는 매우 적극적인 방법으로 바인딩할 수 있는 목록을 지정해서 그 외의 모든 요청 파라미터는 다 막아준다. 따라서 매우 안전하다.
- 반대로 후자는 기본적으로는 다 허용하지만 특별한 이름을 가진 요청 파라미터만 막아준다.
- 보안수준과 정책에 따라서 이 두 가지 중 하나를 적절히 활용할 수 있다.
- 사용 방법은 프로퍼티 에디터 등을 설정하는 경우와 동일하게 @InitBinder나 WebBindingInitializer에서
  WebDataBinder 오브젝트의 프로퍼티를 설정해주는 것이다.
- 다음은 해당 컨트롤러의 모든 @ModelAttribute 바인딩에서 name, email, tel 세 가지 HTTP 요청 파라미터
  외에는 사용하지 못하도록 허용된 필드를 지정하는 코드의 예이다.
  ```java
  @InitBinder
  public void initBinder(WebDataBinder dataBinder) {
    dataBinder.setAllowedFields("name", "email", "tel");
  }
  ```
- 이 세 개의 허용된 필드 외의 이름을 가진 HTTP 파라미터가 오면 어떻게 될까?
  그 파라미터는 모델 오브젝트의 바인딩에서 제외된다. 따라서 아무리 level, point, type과 같은 필드 정보를
  강제로 보낸다고 해도 무시된다.
- 필드 이름은 \*name, tel\*, \*type\* 처럼 와일드카드를 이용해 지정할 수도 있다.

## requiredFields
- 컨트롤러가 자신이 필요로 하는 필드 정보가 폼에서 모두 전달됐는지를 확인하고 싶을 때가 있다.
- 컨트롤러 메소드에서 수동으로 HTTP 파라미터를 가져와 코드로 직접 바인딩하는 경우라면 특정 HTTP 파라미터가 존재하는지 아닌지를 확인할 수 있다.
- 가장 원시적인 방법은 다음과 같이 HttpServletRequest.getParameter()로 가져온 값이 null인지 확인하는 것이다.
  ```java
  String name = request.getParameter("name");
  if(name == null) throw new MissingServletRequestParameterException (...);
  user.setName(name);
  ```
- 좀 더 세련되게 하려면 스프링이 제공하는 유틸리티 메소드를 사용할 수 있다.
  getRequiredStringParameter() 메소드는 파라미터가 존재하지 않으면 예외를 발생시킨다.
  ```java
  user.setName(ServletRequestUtils.getRequiredStringParamter(request, "name"));
  ```
- 이렇게 코드에 의해 바인딩을 하는 대신 전달된 HTTP 파라미터를 알아서 모델 오브젝트에 바인딩하는 경우,
  파라미터가 전달됐는데 타입이 안맞거나 하는 문제라면 간단히 검증이 되지만, 반드시 필요한 필수 파라미터가 없다고 해서 예외를 발생시키거나하진 않는다.
- 그래서 필요하다면 필수 HTTP 파라미터를 WebDataBinder에 알려주고, 바인딩 시 필수 파라미터 중에서 빠진 게 있다면
  바인딩 에러로 처리하도록 만들어줄 수 있다. 
- 이 때 사용하는 것이 requiredFileds다. WebDataBinder의 setRequiredFields() 메소드를 호출해서 필수 파라미터의 이름을 넣어주면 된다.

## fieldMarkerPrefix
- WebDataBinder의 fieldMarkerPrefix 프로퍼티는 이 프로퍼티 값을 다르게 설정해서 사용하기 위해서라기보다는
  필드마커가 어떤 식으로 사용되는지를 이해하는게 더 중요하다.
- requiredFields 항목에서 설명했듯이 자동 바인딩의 단점은 HTTP 요청 파라미터가 전달되는 것이 있으면 그것만
  모델의 프로퍼티에 바인딩해준다는 점이다.
- 컨트롤러의 코드에서 직접 바인딩 작업을 하는 방식에 비해 훨씬 편리하지만, 그만큼 신경 쓸 사항이 있다.
- 특히 폼에서 필요한 필드정보를 제공해주지 않으면 해당 프로퍼티에는 아무런 변화가 일어나지 않는다는 점에 주의해야 한다.
- JSP 뷰의 폼을 작성하는 개발자나 디자이너가 실수로 빼먹은 필드가 있는지를 검증하려면 requiredFields를 이용하면 된다.
- 하지만 폼에 필드를 분명 넣어줬음에도 불구하고 HTTP 파라미터가 제공되지 않는 희한한 경우가 한 가지가 있다. 바로 폼의 체크박스다.
- 다음과 같이 체크박스를 폼의 필드로 선언했다고 해보자. 사용자가 체크박스에 체크를 하고 폼을 서브밋하면 autoLogin이라는 이름의 HTTP 파라미터로 on이라는 값이 들어온다.
  @ModelAttribute 모델의 autoLogin 프로퍼티가 boolean 타입이라면 true 값이 바인딩된다. 여기까지는 아무런 문제가 없다.
  ```html
  <input type="checkbox" name="autoLogin" />
  ```
- 문제는 체크박스를 해제하고 폼을 서브밋할 때다. 이때는 HTTP 요청 파라미터 autoLogin에 off나 false 같은 값이 전달된다면 아무런 문제가 없다.
- 문제는 희한하게도 HTML 폼의 체크박스는 체크를 하지 않으면 아예 해당 필드의 값을 서버로 전송하지 않는다는 점이다.
- HTTP 요청 파라미터 목록에 autoLogin이라는 이름을 가진 것이 아예 없다는 것이다.
- 코드에서 수동 바인딩을 한다면 별문제가 없다.
- 체크를 하지 않았다면 request.getParameter()의 값이 null로 올 것이고, 이 경우에는 해당 프로퍼티에 false를 넣어주면 된다.
- 하지만 HTTP 요청 파라미터를 모두 가져다가 그에 해당하는 모델 프로퍼티에 값을 넣어주는 @ModelAttribute 자동 바인딩 방식에서는 심각한 문제가 발생한다.
- 수정 화면의 경우를 생각해보자. 모델의 autoLogin 프로퍼티는 처음에 true로 설정되어 있다면 HTML 폼의 체크박스는 체크되어 있을 것이다.
- 사용자가 체크박스를 해제하고 서브밋을 누르면, HTTP 요청은 autoLogin 파라미터가 존재하지 않은 채로 전송된다.
  스프링은 @SessionAttribute를 통해 저장해뒀던 모델 오브젝트를 가져와서 HTTP 요청 파라미터가 있는 것만 바인딩할 테니,
  autoLogin 프로퍼티는 그에 해당하는 HTTP 파라미터가 없으므로 아무런 변화 없이 true 값이 그대로 남게 돼버린다.
- 사용자는 분명 체크를 해제했는데 모델의 해당 프로퍼티 값은 false로 바뀌지 않는 심각한 문제가 발생한다.
- 이 문제를 어떻게 해결할 수 있을까? HTML의 체크박스 전송 방식을 바꿀 방법은 없다.
- 유일한 해결책은 바인더에게 특정 필드를 체크박스라고 알려줘서, 만약 해당 필드의 이름을 가진 HTTP 요청 파라미터가
  전달되지 않으면 이는 체크박스를 해제했기 때문이라고 판단할 수 있게 해줘야 한다.
- 이를 위해 스프링은 특별한 접두어가 붙은 필드 이름을 가진 마커(marker) 히든 필드를 추가하는 방식을 사용한다.
- 다음은 스프링 컨트롤러로 전송되는 HTML 폼에 체크박스를 넣는 전형적인 코드다.
  ```html
  <input type="checkbox" name="autoLogin" />
  <input type="hidden" name="_autoLogin" value="on" />
  ```
- 체크박스를 넣을 때는 이렇게 히든 필드를 하나 추가하고, 체크박스의 필드 이름 앞에 밑줄(_)을 붙인 것을 히든 필드 이름으로 넣는다.
- 체크박스 필드의 이름 앞에 붙는 이런 밑줄과 같은 것을 **필드마커**라고 부른다.
- 스프링은 필드마커가 있는 HTTP 파라미터를 발견하면 필드마커를 제외한 이름의 필드가 폼에 존재한다고 생각한다.
- 그런데 그 필드 이름의 파라미터가 요청정보에 존재하지 않는다면 이는 체크박스를 해제했기 때문이라고 판단하고, 그 이름에 해당하는
  프로퍼티 값을 리셋해준다. 리셋하는 방식은 boolean 타입이면 false를, 배열 타입이라면 빈 배열을, 그 외 타입이라면 null을 넣어주는 것이다.
- 이렇게 체크박스를 사용했다고 하더라도 필드마커를 통해 필드의 존재를 알 수 있기 때문에 체크박스의 값이 전달되지 않아도 모델 파라미터를
  바르게 바인딩하는 데 문제가 없다.
- WebDataBinder의 fieldMarkerPrefix는 바로 이 필드마커로 사용되는, 히든 필드의 이름 앞에 붙이는 접두어를 지정한다.
- 기본은 밑줄 하나인데, 만약 다른 필드마커를 사용하고 싶다면 WebDataBinder의 setFieldMarker() 메소드를 이용해 변경해주면 된다.
- 체크박스를 사용한다고 매번 필드마커를 넣는 것은 사실 귀찮은 일이다. 하지만 다음 절에서 다룰 스프링의 form 태그를 사용하면
  체크박스를 위한 필드마크를 자동으로 추가해주므로 염려하지 않아도 된다.
- 혹시 스프링이 제공하는 form 태그를 사용하는 대신 HTML의 표준 태그를 사용해 체크박스를 넣었다면 이 필드마크가 붙은 히든 필드를 절대 잊으면 안된다.

## fieldDefaultPrefix
- WebDataBinder의 프로퍼티인 fieldDefaultPrefix의 디폴트 값은 느낌표(!)다.
- 필드 디폴트는 히든 필드를 이용해 체크박스에 대한 디폴트 값을 지정하는 데 사용한다.
- 때로는 체크박스에 대응되는 모델의 프로퍼티 타입이 단순한 boolean 타입이 아닐 수 있다.
- User 모델 클래스 안에 String 타입인 type이라는 프로퍼티가 있다고 하자.
  여기에는 사용자가 관리자라면 admin을 넣고, 일반 회원이라면 member를 넣는다고 하자.
- 이 타입의 정보를 HTML 폼을 통해 입력받으려면 어떻게 해야 할까?
- 값이 고정이므로 텍스트박스 보다는 셀렉트박스를 사용하는게 편할 것이다.
- 하지만 매번 선택하기가 귀찮아서 아예 체크박스로 바꿀 수도 있다. 즉 다음과 같이 태그를 구성할 수 있다.
  ```html
  <span>관리자(?) : </span><input type="checkbox" name="type" value="admin" />
  ```
- 이때는 체크박스 태그의 값을 넣었으므로 체크하고 서브밋하면 type 파라미터로 "admin" 이라는 문자열이 전달된다.
- 문제는 역시 체크박스를 체크하지 않았을 때다. 이때는 type이라는 파라미터가 아예 전달되지 않는다.
- 이렇게 파라미터가 넘어오지 않을때는 해당 프로퍼티에 "member"라는 값을 넣어주려면 어떻게 해야 할까?
- 바로 이때 필드 디폴트를 사용하면 된다.
- 필드 디폴트 접두어의 기본 값은 느낌표 한 개이므로 다음과 같은 히든 필드를 추가해준다.
  ```html
  <input type="hidden" name="!type" value="member" />
  ```
- 이렇게 필드 디폴트를 설정해주면 WebDataBinder는 !type이라는 필드 디폴트를 확인하고, type이라는 이름의 파라미터가 존재하지 않는다면
  필드 디폴트의 value 값에 담긴 내용을 해당 프로퍼티에 바인딩해준다. 따라서 type에 member라는 값이 들어갈 것이다.
- WebDataBinder의 fieldDefaultPrefix를 이용하면 기본으로 설정된 느낌표 대신 다른 접두어를 지정할 수 있다.
- 느낌표로 시작하는 필드 이름은 사용될 일이 없으므로 특별한 이유가 없다면 변경하지 않는 것이 좋다.
- 대신 필드 디폴트를 이용해 체크박스의 디폴트 값을 설정해주는 방법은 잘 기억해두자.
