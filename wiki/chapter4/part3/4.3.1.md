# 4.3.1 PropertyEditor
- 스프링이 기본적으로 제공하는 바인딩용 타입변환 API 

## 디폴트 프로퍼티 에디터
- 프로퍼티 에디터는 XML의 value 애트리뷰트뿐만 아니라 @Controller의 파라미터에도 동일하게 적용된다.
- URL이 /hello?charset=UTF-8이라면, 다음 컨트롤러 메소드의 charset 파라미터는 UTF-8로 설정된 Charset 타입의 오브젝트를 받게 될 것이다.
  ```java
  @RequestMapping("/hello")
  public void hello(@RequestParam Charset charset, Model model){}
  ```
- UTF-8이라는 문자열로 들어온 파라미터를 바인딩 과정에서 메소드 파라미터 타입인 Charset으로 전환하기 위해 스프링이 디폴트로 등록해준
  CharsetEditor를 적용했기 때문이다.
- 다음은 CharsetEditor를 이용해 직접 코드에서 UTF-8이라는 문자를 Charset 타입으로 변경해보는 간단한 학습 테스트다.
  ```java
  @Test
  public void charsetEditor() {
    CharsetEditor charsetEditor = new CharsetEditor();
    charsetEditor.setAsText("UTF-8");
    assertNotNull(charsetEditor.getValue());
    assertEquals(charsetEditor.getValue(), StandardCharsets.UTF_8);
  }
  ```
- 바인딩 과정에서는 변환할 파라미터 또는 모델 프로퍼티의 타입에 맞는 프로퍼티 에디터가 자동으로 선정돼서 사용된다.
- 기본적으로 스프링이 제공하는 프로퍼티 에디터의 종류와 지원 타입이 어떤것인지 기억해두고 이를 활용하자.  
  (Spring API Document의 org.springframework.beans.propertyeditors 패키지 참조)
- 만약 스프링이 지원하지 않는 타입을 파라미터로 사용한다면, 이때는 직접 프로퍼티 에디터를 만들어서 적용할 수도 있다.

## 커스텀 프로퍼티 에디터
- 애플리케이션에서 직접 정의한 타입으로 직접 바인딩을 하고 싶다면, 프로퍼테 에디터를 직접 작성하면 된다.
- 예를들어 Vol.1에서 만들었던 User 클래스의 level 프로퍼티를 생각해보자. 이 프로퍼티는 다음과 같은 Level 이늄 타입이다.
- 스프링은 당연히 Level 타입을 알지 못한다. 따라서 파라미터를 직접 매핑할 수 있는 방법은 없다.
- Level의 각 요소에는 기본적으로 다음과 같이 DB에 저장할 때 사용할 값을 지정해뒀다.
- 이 값에 대응되는 Level 오브젝트를 가져오는 valueOf() 스태틱 메소드와 Level 오브젝트에서 값을 읽어오는 intValue() 메소드도 함께 제공된다.
  ```java
  public enum Level {
    GOLD(3, null), SILVER(2, GOLD), BASIC(1, SILVER);
    ...
    public int intValue() {
      return value;
    }
  
    public static Level valueOf(int value) {
      swtich(value) {
        case 1: return BASIC;
        case 2: return SILVER;
        case 3: return GOLD;
        default: throw new AssertionError("Unknown value: " + value);
      }
    }
  }
  ```
- 이 두 개의 메소드를 이용하면 1,2,3 같은 값과 Level 오브젝트 사이에 변환이 가능하다.
- 1,2,3은 물론 문자로 표현되어 있어도 상관없다. 간단히 숫자로 바꿔줄 수 있기 때문이다.
- Level을 지원하는 프로퍼티 에디터를 만들어서 다음과 같은 컨트롤러 메소드가 /user/search?level=1에 대해 정상적으로 동작하도록 만들어보자.
  ```java
  @RequestMapping("/user/search")
  search(@RequestParam Level level) { ... }
  ```
- Level에 대한 프로퍼티 에디터 없이 URL에 level=1이라고 파라미터를 줘서 위의 메소드를 실행시키면 어떻게 될까?
- 이때는 String 타입을 Level로 변환할 수 없어서 발생하는 ConversionNotSupportedException 예외 때문에 HTTP 500 에러를 만나게 될 것이다.
- 이제 Level 타입에 대한 프로퍼티 에디터를 만들어보자.
- PropertyEditor에서 변환을 위해 사용되는 메소드는 총 네 가지가 있다.
- HTTP 요청 파라미터와 같은 문자열 스트링 타입으로 서블릿에서 가져온다.
  스프링이 이 스트링 타입의 문자열을 변경할 타입의 오브젝트로 만들 때는 프로퍼티 에디터의 두 개의 메소드가 사용된다.
- 먼저 setAsText() 메소드를 이용해 스트링 타입의 문자열을 넣고 getValue()로 변환된 오브젝트를 가져온다.
- 반대로 오브젝트를 다시 문자열로 바꿀때는 setValue()로 오브젝트를 넣고 getAsText() 메소드로 변환된 문자열을 가져온다.
- 여기서 getValue()와 setValue()는 오브젝트를 저장하고 가져올 때 사용하는 것이므로 손댈 것 없고, 구현해줘야 할 메소드는 바로 setAsText()와 getAsText() 두 가지다.
- 다음은 이 네 개의 메소드를 통해 프로퍼티 에디터가 문자열로 된 값을 특정 오브젝트로 변환하거나 그 반대로 변환하는 과정을 보여준다.
  ![프로퍼티 에디터의 동작원리](images/PropertyEditor%20Process.jpg)
- 프로퍼티 데이터를 만들때는 PropertyEditor 인터페이스를 직접 구현하기 보다는
  기본구현이 되어 있는 PropertyEditorSupport 클래스를 상속해서 필요한 메소드만 오버라이드 해주는 편이 낫다.
- setAsText()에서는 스트링 타입의 파라미터를 오브젝트로 변환해서 넣어주고, getAsText()에서는 그 반대로 변환해주는 코드를 작성하면 된다.
- 다음은 문자열과 Level 타입 오브젝트의 변환을 담당하는 프로퍼티 에디터의 구현 코드와 테스트 코드다.
  ```java
  public class LevelPropertyEditor extends PropertyEditorSupport {
    public String getAsText() {
        return String.valueOf(((Level)this.getValue()).intValue());
    }

    public void setAsText(String text) throws IllegalArgumentException {
        this.setValue(Level.valueOf(Integer.parseInt(text.trim())));
    }
  }

  @Test
  public void levelPropertyEditor() {
    LevelPropertyEditor levelEditor = new LevelPropertyEditor();
    
    levelEditor.setValue(Level.BASIC);
    assertThat(levelEditor.getAsText(), is("1"));
    
    levelEditor.setAsText("3");
    assertThat((Level)levelEditor.getValue(), is(Level.GOLD));
  }
  ```

## @InitBinder
- @MVC에는 스프링 컨테이너에 정의된 디폴트 프로퍼티 에디터만 등록되어 있다.
  여기에 LevelPropertyEditor를 추가해서 Level 타입의 변환이 필요할 때 사용되도록 만들어야 한다.
- 먼저 컨트롤러 메소드에서 바인딩이 어떻게 일어나는지 살펴보자.
  @Controller 메소드를 호출해줄 책임이 있는 AnnotationMethodHandlerAdapter는 @RequestParam이나 @ModelAttribute,
  @PathVariable 등처럼 HTTP 요청을 파라미터 변수에 바인딩해주는 작업이 필요한 애노테이션을 만나면 먼저 WebDataBinder를 만든다.
- WebDataBinder는 여러가지 기능을 제공하는데, 그중에 HTTP요청으로부터 가져온 문자열을 파라미터 타입의 오브젝트로 변환하는 기능도 포함되어 있다.
- 물론 이 변환 작업은 프로퍼티 에디터를 이용한다. 따라서 개발자가 직접 만든 커스텀 프로퍼티 에디터를 @RequestParam과 같은 메소드 파라미터 바인딩에
  적용하려면 바로 이 WebDataBinding에 프로퍼티 에디터를 직접 등록해줘야 한다.
- 문제는 WebDataBinder는 AnnotationMethodHandlerAdapter가 복잡한 과정을 통해 메소드 파라미터와 애노테이션 등을 분석하고 바인딩을
  진행하는 과정 내부에서 만들어지기 때문에 외부로 직접 노출되지 않는다는 점이다.
- 스프링이 특별히 제공하는 WebDataBinder 초기화 메소드를 이용해야 한다.
- 컨트롤러 클래스에 다음과 같이 @InitBinder라는 애노테이션이 부여되어 있고, 파라미터로 WebDataBinder 타입이 정의된 메소드를 하나 생성한다.
- 그리고 파라미터로 전달되는 WebDataBinder 오브젝트의 registerCustomEditor() 메소드를 호출해서 LevelPropertyEditor 오브젝트를 등록해주자.
  ```java
  @InitBinder
  public void initBinder(WebDataBinder dataBinder) {
    dataBinder.registerCustomEditor(Level.class, new LevelPropertyEditor());
  }
  ```
- @InitBinder가 붙은 initBinder() 메소드는 메소드 파라미터를 바인딩하기 전에 자동으로 호출한다.
- 그래서 스프링의 디폴트 프로퍼티 에디터만 갖고 있는 WebDataBinder에 커스텀 프로퍼티 에디터를 추가할 수 있는 기회를 제공해준다.
- registerCustomEditor()는 프로퍼티 에디터를 적용할 타입과 프로퍼티 에디터 오브젝트를 넣어서 WebDataBinder에 새로운 프로퍼티 에디터를 추가해주는 메소드다.
- 다음은 WebDataBinder의 사용방법을 테스트하는 코드다.
  ```java
  WebDataBinder dataBinder = new WebDataBinder(null);
  dataBinder.registerCustomEditor(Level.class, new LevelPropertyEditor());
  assertThat(dataBinder.convertIfNecessary("1", Level.class)), is(Level.BASIC); 
  ```
- 바인더 오브젝트를 만들고 추가로 프로퍼티 에디터를 등록해주면 타입 변환 메소드를 이용할 수 있다.
- 물론 WebDataBinder를 코드에서 직접 만들어 수동으로 바인딩할 필요는 없다.
  스프링이 컨트롤러 메소드의 파라미터 모델 프로퍼티를 바인딩할 때 알아서 초기화해둔 WebDataBinder를 이용하기 때문인다.
- 하지만 커스텀 프로퍼티 에디터를 추가하는 것은 컨트롤러 코드를 만드는 개발자의 몫이다.
- 따라서 @InitBinder가 붙은 메소드를 적절히 이용해서 필요한 프로퍼티 에디터를 추가해줘야 한다.
- @InitBinder에 의해 등록된 커스텀 에디터는 같은 컨트롤러의 메소드에서 HTTP 요청을 바인딩하는 모든 작업에 적용된다.
- WebDataBinder의 바인딩 적용 대상은 @RequestParam 파라미터, @CookieValue 파라미터, @RequestHeader 파라미터,
  @PathVariable 파라미터, @ModelAttribute 파라미터의 프로퍼티다.
- 따라서 이런 요청 정보는 프로퍼티 에디터를 통해 적절한 타입 변환을 기대할 수 있다면 String 대신 다른 타입으로 메소드 파라미터를 선언해두는 게 좋다.
- 컨트롤러 메소드 내에서 지저분한 변환 과정을 다시 거칠 필요가 없기 때문이다.
- WebDataBinder에 커스텀 프로퍼티 에디터를 등록하는 방법은 다시 두 가지로 구분해볼 수 있다.

### 특정 타입에 무조건 적용되는 프로퍼티 에디터 등록
- 위의 예처럼 적용 타입과 프로퍼티 에디터 두 개를 파라미터로 받는 registerCustomEditor()를 사용해 프로퍼티 에디터를 등록했다면,
  해당 타입을 가진 바인딩 대상이 나오면 항상 프로퍼티 에디터가 적용된다.
- 디폴트 프로퍼티 에디터에서는 지원하지 않는 타입이라면 기본적으로 이 방식을 사용하는 것이 적절하다.

### 특정 이름의 프로퍼티에만 적용되는 프로퍼티 에디터 등록
- 두 번째 등록 방법은 타입과 프로퍼티 에디터 오브젝트 외에, 추가로 적용할 프로퍼티 이름을 지정하는 것이다.
- 따라서 같은 타입이지만 프로퍼티 이름이 일치하지 않는 경우에는 등록한 커스텀 프로퍼티 에디터가 적용되지 않는다.
- 프로퍼티 이름이 필요하므로 @RequestParam과 같은 단일 파라미터 바인딩에는 적용되지 않는다.
- 모델 오브젝트 안에 같은 타입의 프로퍼티가 여러 개 있다고 해도, 그중에서 프로퍼티 에디터를 등록할 때
  지정한 이름과 일치하는 프로퍼티에만 프로퍼티 에디터가 적용된다.
- 그렇다면 이렇게 프로퍼티 이름까지 직접 지정해서 제한적으로 커스텀 프로퍼티 에디터를 적용해야 할 경우는 언제일까?
  또, 프로퍼티 이름이 일치하지 않아서 커스텀 프로퍼티 에디터가 적용되지 않는 파라미터가 있다면 그 파라미터 바인딩 작업에서는 예외가 발생하지 않을까?
- 이름이 포함된 프로퍼티 에디터의 등록은 이미 프로퍼티 에디터가 존재하는 경우에 사용하기 적합하다.
- WebDataBinder는 바인딩 작업 시 커스텀 프로퍼티 에디터를 먼저 적용해보고 적절한 프로퍼티 에디터가 없으면 그때 디폴트 프로퍼티 에디터를 사용한다.
  즉, 커스텀 프로퍼티 에디터가 우선순위를 갖는다.
- 이미 스프링의 디폴트 프로퍼티 에디터에서 지원하는 int 타입에 대해 커스텀 프로퍼티 에디터를 만든다고 생각해보자.
- 단순히 문자열을 int 타입으로 변환하는 것이 전부가 아니라 부가적인 조건을 부여해줄 필요가 있기 때문이다.
- 다음은 int 타입을 지원하는 커스텀 프로퍼티 에디터의 예다.
  이름 그대로 최소값과 최대값을 지정할 수 있고, 이 범위에 포함되지 않는 값이 있으면 강제로 최소값이나 최대값으로 변경한다.
  ```java
  public class MinMaxPropertyEditor extends PropertyEditorSupport {
    int min;
    int max;
  
    public MinMaxPropertyEditor(int min, int max) {
      this.min = min;
      this.max = max;
    }
  
    @Override
    public String getAsText() {
      return String.valueOf((Integer)this.getValue());
    }

    @Override
    public void setAsText(String text) throws IllegalArgumentException {
      Integer val = Integer.parseInt(text);
      if(val < min) {
        val = min;
      }
      else if(val > max) {
        val = max;
      }
      setValue(val);
    }
  }
  ```
- 다음과 같이 두 개의 int 타입을 갖는 오브젝트가 있다.
  ```java
  public class Member {
    int id;
    int age;
    // 수정자, 접근자 코드 생략
  }
  ```
- 컨트롤러 메소드는 다음과 같이 Member 타입의 프로퍼티에 HTTP 요청 파라미터를 바인딩해주도록 @ModelAttribute로 선언한다.
  ```java
  @RequestMapping("/add")
  public void add(@ModelAttribute Member member) { ... }
  ```
- 별도의 프로퍼티 에디터를 등록하지 않았다고 하면, URL이 /add?id=1000&age=1000 이라고 주어졌을때 디폴트로 등록된 int 타입의
  프로퍼티 에디터가 동작해서 Member 오브젝트의 id, age에 각각 1000이라는 값을 넣어줄 것이다.
- 그런데 age는 단순 일련번호인 id와 달리 사람의 나이를 나타내므로 int 타입이긴 하지만 적절한 범위 안의 값만 사용해야 한다.
  그래서 int 타입에 대해 MinMaxPropertyEditor를 등록해버리면 id에도 적용되는 문제가 발생한다.
- 커스텀 프로퍼티 에디터는 디폴트 프로퍼티 에디터보다 우선하기 때문에 모든 int 타입의 파라미터에 다 MinMaxPropertyEditor가 적용된다.
- 그래서 MinMaxPropertyEditor는 int 타입의 프로퍼티 중에서도 이름이 age인 경우에만 적용하도록 만들어줘야 한다.
- 이를 위해 다음과 같이 프로퍼티 이름을 지정하는 커스텀 프로퍼티 에디터 등록 방식을 사용해야 한다.
  ```java
  @InitBinder
  public void initBinder(WebDataBinder dataBinder) {
    dataBinder.registerCustomEditor(int.class, "age", new MinMaxPropertyEditor(0, 200));
  }
  ```
- 이렇게 해주면 MinMaxPropertyEditor는 Member 오브젝트의 int 타입 프로퍼티 중에서 age라는 이름의 프로퍼티에만 적용된다.
- id 프로퍼티는 MinMaxPropertyEditor의 적용 대상이 되지 않으므로 디폴트로 등록된 int 타입의 프로퍼티 에디터에 의해 정수 값으로 변환해줄 것이다.
- 따라서 /add?id=1000&age=1000 URL이 주어졌을때 바인딩을 거쳐서 컨트롤러 메소드가 전달받는 member 오브젝트에는
  id 프로퍼티에 1000, age 프로퍼티에 최대값으로 설정한 200이 들어간다.
- @InitBinder 메소드의 파라미터에는 WebDataBinder 외에 WebRequest도 사용할 수 있다.
- WebRequest는 HttpServletRequest에 들어있는 거의 모든 HTTP 요청정보를 담고 있다.
  따라서 HTTP 요청에 따라 다른 방식으로 WebDataBinder에 프로퍼티 에디터 등을 설정하는데 활용할 수 있다.

### [학습테스트 - MinMaxPropertyEditor](/src/main/java/com/hello4/controller/Hello4Controller.java)

## WebBindingInitializer
- @InitBinder 메소드에서 WebDataBinder에 추가한 커스텀 프로퍼티 에디터는 메소드가 있는 컨트롤러 클래스 안에서만 동작한다.
- Level 타입의 바인딩이 애플리케이션 전반에 걸쳐 폭넓게 필요한 경우라면, @InitBinder 메소드를 컨트롤러마다 추가하고 LevelPropertyEditor를
  등록하는 코드를 반복적으로 추가해줘야 한다.
- 같은 컨트롤러 내에서는 모든 컨트롤러 메소드에 한 번에 적용되긴 하지만, 컨트롤러 클래스가 다를경우 다시 등록해주는 코드를 넣어야 한다면 매우 번거로운 일이다.
- 그래서 이렇게 모든 컨트롤러에 적용해도 될 만큼 많은 곳에서 필요한 프로퍼티 에디터라면 등록하는 방법을 달리해서 한 번에 모든 컨트롤러에 적용하는 편이 좋다.
- 이런 용도로 만들어진 WebBindingInitializer를 이용하면 된다.
- 먼저 WebBindingInitializer 인터페이스를 구현해서 다음과 같은 클래스를 작성한다. 구현할 메소드는 @InitBinder를 적용했던 메소드와 비슷하다.
- WebDataBinder를 전달받아서 커스텀 프로퍼티 에디터를 추가하는 코드를 넣는다.
  ```java
  public class MyWebBindingInitializer implements WebBindingIntializer {
    public void initBinder(WebDataBinder binder, WebRquest request) {
      binder.registerCustomEditor(Level.class, new LevelPropertyEditor());
    }
  }
  ```
- WebBindingInitializer를 구현해서 만든 클래스를 빈으로 등록하고 @Controller를 담당하는 어댑터 핸들러인
  AnnotationMethodHandlerAdapter의 webBindingInitializer 프로퍼티에 DI 해준다.
- 이 프로퍼티 설정을 위해서는 AnnotationMethodHandlerAdapter도 빈으로 직접 등록해야 한다.
- WebBindingInitializer는 다른 곳에서 참조할 일은 없으므로 다음과 같이 내부 빈 설정 방식을 이용해 등록해도 좋다.
  ```xml
  <bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMehtodHandlerAdapter">
    <property name="webBindingInitializer">
      <bean class="springbook...MyWebBindingInitializer" />
    </property>
  </bean>
  ```
- 이렇게 AnnotationMethodHandlerAdapter 레벨에 바인딩을 초기화하는 빈을 등록해주면 이 빈의 initBinder() 메소드는
  모든 컨트롤러의 모든 바인딩 작업에 일괄 적용된다.
- 따라서 LevelPropertyEditor를 매번 @InitBinder 메소드를 통해 컨트롤러마다 등록해줄 필요가 없게 된다.
- 물론 Level 타입의 바인딩이 필요 없는 컨트롤러에도 매번 적용되는 낭비가 있기는 하다.
  하지만 프로퍼티 에디터는 워낙 간단한 클래스이므로 자주 생성되도 별문제가 되지 않는다.
- 적절한 기준을 정해두고 일정 비율 이상의 컨트롤러에서 필요로 하는 커스텀 프로퍼티 에디터는 WebBindingInitializer를 이용해 등록하는 방법을 검토해보자.

## 프로토타입 빈 프로퍼티 에디터
- 지금까지 등장한 모든 커스텀 프로퍼티 에디터 등록 코드를 잘 살펴보면, 모든 메소드에서 매번 new 키워드를 사용해 프로퍼티 에디터 오브젝트를 새로 만들고 있음을 알 수 있다.
- @InitBinder 메소드나 WebBindingInitializer 메소드에서도 마찬가지다.
  프로퍼티 바인딩을 할 때마다 매번 새로운 프로퍼티 에디터 오브젝트를 만들어 사용한다는 것이다.
- 오브젝트를 매번 새로 만드는 대신 프로퍼티 에디터를 싱글톤 빈으로 등록해두고 이를 공유해서 쓸 수는 없을까?
  안타깝지만 프로퍼티 에디터는 싱글톤 빈으로 등록될 수 없다.
- 프로퍼티 에디터를 테스트하기 위해 작성했던 코드를 다시 잘 살펴보면 모든 변환 과정은 하나의 메소드가 아니라 두 개의 메소드가 사용됨을 알 수 있다.
- 프로퍼티 에디터에 setValue()를 이용해 오브젝트를 일단 넣은 후에 getAsText()로 변환된 문자열을 가져오는 식이다.
  프로퍼티 에디터에 의해 타입이 변경되는 오브젝트는 한 번은 프로퍼티 에디터 오브젝트 내부에 저장된다는 사실을 알 수 있다.
- 따라서 프로퍼티 에디터는 짧은 시간이지만 상태를 갖고 있게 된다.
  이 때문에 프로퍼티 에디터는 멀티스레드 환경에서 싱글톤으로 만들어 여러 오브젝트가 공유해서 사용하면 안된다.
- 자칫하면 다른 스레드에서 변환하는 값으로 덮어쓰일 수 있다.
- 그래서 바인딩을 할 때마다 매번 initBinder() 같은 초기화 메소드를 호출해서 새로운 프로퍼티 에디터 오브젝트를 만들어 사용하는 것이다.
- 프로퍼티 에디터는 싱글톤 빈으로 등록해서 공유해서는 안된다는 사실을 꼭 기억하기 바란다.
- 깜빡하고 프로퍼티 에디터를 싱글톤 빈으로 등록했다면, 한 명의 사용자가 진행하는 테스트에서는 아무 문제가 발견되지 않겠지만,
  시스템이 운영서버에 배치되고 나서는 고객의 정보에 가끔 엉뚱한 값이 들어가는 것과 같은, 원인을 파악하기도 힘들고 재현하기도 매우 어려운
  골치 아픈 버그를 만날 수도 있다.
- 따라서 프로퍼티 에디터는 지금까지 등장했던 코드에서처럼 매번 new 키워드로 새로 오브젝트를 만들어 사용해야 한다.
- 그런데 프로퍼티 에디터가 다른 스프링 빈을 참조해야 한다면 어떨까? 프로토타입 빈으로 만들자.
- 어떤 경우에 프로퍼티 에디터가 다른 빈을 참조해야 할까?
  자주 활용 되는 건, HTTP 요청 파라미터로 도메인 오브젝트의 ID를 제공받으면 이를 바인딩 과정에서 ID에 해당하는 실제 도메인 오브젝트로 만들어 주는 것이다.
- 즉 ID를 가지고 DB에 도메인 오브젝트 전체를 가져오는 과정이 필요하다는 뜻이다.
- 물론 ID를 int 타입 등으로 그냥 받아서 서비스 계층으로 전달한 뒤에 거기서 DAO를 통해 해당 ID에 대한 도메인 오브젝트를 가져오게 할 수도 있다.
- 하지만 좀 더 객체 지향적인 서비스 계층을 설계한다면 도메인 오브젝트의 ID 값보다는 도메인 오브젝트 자체를 전달받는 비즈니스 로직 메소드를 작성하는 편이 낫다.
- 또한 폼에서 사용되는 모델 오브젝트의 특정 프로퍼티가 다른 도메인 오브젝트 타입인 경우가 많다. 이런 경우의 폼 데이터 바인딩 방법을 생각해보자.
- 다음과 같은 프로퍼티를 갖는 User 클래스가 있다고 해보자.
  ```java
  public class User {
    int id;
    String name;
    Code userType;
    // 수정자, 접근자 코드 생략
  }
  ```
- 세 번째 프로퍼티인 userType은 그 타입이 Code다. 이 Code가 이늄처럼 프로퍼티 에디터를 만들어서 처리할 수 있는 것이라면 문제가 되지 않을 것이다.
- 하지만 Code도 DB에 저장되는 독립적인 도메인 오브젝트라면 어떨까?
  애플리케이션에서 다이내믹하게 사용자 타입을 추가하거나 삭제할 수 있도록, 이렇게 DB의 코드 테이블을 활용하는건 매우 흔한 일이다.
- 일단 Code는 id와 name이라는 두 가지 프로퍼티만 가진 간단한 도메인 오브젝트로 가정하자.
- 보통 사용자 정보를 수정하는 폼에는 userType에 해당하는 코드의 내용이 출력된 \<select> 박스가 표시되고 그중에서 하나를 선택하게 한다.
- 폼을 출력하는 컨트롤러에서는 다음과 같이 @ModelAttribute 메소드를 이용해서 userType에 적용될 수 있는 코드 목록을 참조정보 모델로 제공하는 메소드가 만들어질 것이다.
  ```java
  @ModelAttribute("userTypes")
  public List<Code> userTypes() {
    return this.codeService.findCodesByCodeCategory(CodeCategory.USERTYPE);
  }
  ```
- 화면에 출력된 셀렉트박스에는 다음과 같이 Code의 name과 같이 의미 있는 내용이 들어 있겠지만 폼을 전송할 때 사용되는 value에는 Code의 id 값이 들어있을 것이다.
  ```html
  <select name="userType">
    <option value="1">관리자</option>
    <option value="2">회원</option>
    <option value="3">손님</option>
  </select>
  ```
- 이 중에서 '관리자'를 선택하고 폼을 서브밋하면 서버에 전달되는 HTTP 요청에는 userType이라는 이름의 파라미터에 1이라는 값이 들어있을 것이다.
- 이 폼의 모델은 User일 것이고, 따라서 폼의 수정을 처리하는 컨트롤러 메소드는 다음과 같이 정의되어 있을 것이다.
  ```java
  @RequestMapping("/add")
  public void add(@ModelAttribute User user) { ... }
  ```
- User의 id, name 프로퍼티에 해당하는 HTTP 요청 파라미터는 별문제 없이 간단히 바인딩된다.
- 하지만 userType 프로퍼티에 전달되는 1이라는 값은 간단히 Code 타입으로 전환될 수 없다.
- 프로퍼티 이름을 따라서 값을 넣으려면 setUserType(Code userType)이라는 수정자 메소드를 만날텐데,
  스프링은 1이라는 값을 Code 오브젝트로 만들 방법을 알 수가 없다.
- 따라서 어떻게든 프로퍼티 에디터를 사용하는 방식이 필요할 것 같다.
- 이렇게 폼의 파라미터가 모델의 프로퍼티에 바인딩될 때 단순 타입이 아닌 경우 어떻게 이를 바인딩할 수 있는지 몇 가지 방법을 살펴보자.
  ### 별도의 codeid 필드로 바인딩하는 방법
  + 첫 번째 방법은 가장 단순하다. 대신 서비스 계층이나 컨트롤러에서 추가적으로 해줘야할 작업이 있다.
  + 이 방법은 Code userType 프로퍼티로 직접 바인딩 하는 대신 참조 ID 값을 저장할 수 있도록 별도의 임시 프로퍼티를 만들고 이 프로퍼티로 값을 받는 것이다.
  + 비즈니스 로직이나 DAO에서는 직접 사용되지 않지만 웹 파라미터의 바인딩을 위해 다음과 같이 userTypeId라는 프로퍼티를 User 클래스에 추가한다.
    ```java
    public class User {
      ...
      Code userType;
      int userTypeId;
    }
    ```
  + 그리고 \<select>의 이름을 다음과 같이 userTypeId로 변경한다.
    ```html
    <select name="userTypeId">
      ...
    </select>
    ```
  + 이렇게 바꿔주면 폼의 셀렉트박스를 통해 선택한 사용자 타입의 값은 userTypeId라는 이름의 요청 파라미터로 전달되어 User 오브젝트의 userTypeId 프로퍼티에 들어간다.
  + 물론 바인딩이 끝나도 Code 타입인 userType 프로퍼티는 비어 있거나 수정하기전 상태의 값을 갖고 있을 것이다.
  + 이렇게 전달받은 userTypeId 프로퍼티를 이용해 컨트롤러나 서비스 계층에서 적절한 Code 타입의 오브젝트로 변경해서 userType 프로퍼티를 설정해주면 된다.
  + 컨트롤러라면 다음과 같이 작성할 수 있다.
    ```java
    @RequestMapping("/add")
    public void add(@ModelAttribute User user) {
      user.setUserType(this.codeService.getCode(user.getUserTypeId()));
      ...
    }
    ```
  + 또는 이런 컨트롤러 바인딩 결과를 알고 있는, 강한 결합도를 가진 서비스 계층 메소드에서 같은 작업을 먼저 해줄 수도 있다.
  + 어떻게든 userTypeId로 받은 Code의 id에 해당하는 값을 이용해 DB에서 Code 오브젝트를 가져와서 userType 프로퍼티에 넣어줘야 한다.
  + 이 방식을 적용하면 폼의 결과를 바인딩받은 User는 그 자체로 완벽하게 프로퍼티 정보를 담고 있는 오브젝트가 되고,
    서비스 계층의 비즈니스 로직이나 DAO에서 DB에 저장하기 위해 Code 테이블의 외래키를 가져올 때도 유용하게 쓸 수 있다.
  + 가장 간단한 방법이지만 그만큼 단점이 있다.
  + 매번 Code 정보를 DB에서 가져와야 하는 부담이 있다.
  + 물론 JPA나 하이버네이트를 사용한다면 Code 같은 참조 위주의 도메인 오브젝트는 메모리 캐시에 저장해두고 이를 활용하도록 설정할 수
    있기 때문에 성능 자체에는 별 부담이 되지 않을 수 있긴 하다.
  + 설령 DB를 한 번도 조회하지 않더라도, 프로퍼티의 값이 모두 잘 들어가 있는 User 오브젝트를 사용할 수 있으므로 서비스 계층의 코드를 작성하기가 매우 편해진다.
  + 사실 ID와 같은 기본키로 코드를 조회하는 정도는 DB 최적화만으로도 성능에 별 지장을 주지 않도록 만들 수 있다.
  + 이 방식의 가장 큰 단점은 매번 컨트롤러나 서비스 계층 코드에서 위와 같이 id에 해당하는 임시 프로퍼티 값을 이용해서
    도메인 오브젝트 타입의 프로퍼티를 설정해주는 작업을 해야 한다는 것이다.
  + 이런 식의 오브젝트 타입 프로퍼티의 개수가 많아지면 코드가 매우 지저분해지기 쉽다. 실수로 빼먹을 위험도 있다.
  + 또 한 가지 문제는 User 오브젝트에 굳이 필요하지 않은 userTypeId와 같은 임시 저장용 프로퍼티가 추가돼야 한다는 점이다.
  + 도메인 오브젝트의 프로퍼티 구성이 깔끔하지 않은건 별로 좋아 보이지 않는다. 이 문제를 피하려면 차라리 @RequestParam int userTypeId라고
    파라미터를 별도로 추가해서 ID 값을 받는 편이 User라는 중요한 도메인 오브젝트를 깔끔하게 유지할 수 있으므로 더 낫다고 볼 수 있다.
  + 대신 비슷한 종류의 프로퍼티가 많아지면 컨트롤러 메소드 선언이 길어질 위험이 있긴 하다.

  ### 모조 오브젝트 프로퍼티 에디터

  ### 프로토타입 도메인 오브젝트 프로퍼티 데이터