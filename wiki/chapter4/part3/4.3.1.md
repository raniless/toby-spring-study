# 4.3.1 PropertyEditor
- 스프링이 기본적으로 제공하는 바인딩용 타입변환 API 

## 디폴트 프로퍼티 에디터
- 프로퍼티 에디터는 XML의 value 애트리뷰트뿐만 아니라 @Controller의 파라미터에도 동일하게 적용된다.
- URL이 /hello?charset=UTF-8이라면, 다음 컨트롤러 메소드의 charset 파라미터는 UTF-8로 설정된 Charset 타입의 오브젝트를 받게 될 것이다.
  ```java
  @RequestMapping("/hello")
  public void hello(@RequestParam Charset charset, Model model){}
  ```
- UTF-8이라는 문자열로 들어온 파라미터를 바인딩 과정에서 메소드 파라미터 타입인 Charset으로 전환하기 위해 스프링이 디폴트로 등록해준
  CharsetEditor를 적용했기 때문이다.
- 다음은 CharsetEditor를 이용해 직접 코드에서 UTF-8이라는 문자를 Charset 타입으로 변경해보는 간단한 학습 테스트다.
  ```java
  @Test
  public void charsetEditor() {
    CharsetEditor charsetEditor = new CharsetEditor();
    charsetEditor.setAsText("UTF-8");
    assertNotNull(charsetEditor.getValue());
    assertEquals(charsetEditor.getValue(), StandardCharsets.UTF_8);
  }
  ```
- 바인딩 과정에서는 변환할 파라미터 또는 모델 프로퍼티의 타입에 맞는 프로퍼티 에디터가 자동으로 선정돼서 사용된다.
- 기본적으로 스프링이 제공하는 프로퍼티 에디터의 종류와 지원 타입이 어떤것인지 기억해두고 이를 활용하자.  
  (Spring API Document의 org.springframework.beans.propertyeditors 패키지 참조)
- 만약 스프링이 지원하지 않는 타입을 파라미터로 사용한다면, 이때는 직접 프로퍼티 에디터를 만들어서 적용할 수도 있다.

## 커스텀 프로퍼티 에디터
- 애플리케이션에서 직접 정의한 타입으로 직접 바인딩을 하고 싶다면, 프로퍼테 에디터를 직접 작성하면 된다.
- 예를들어 Vol.1에서 만들었던 User 클래스의 level 프로퍼티를 생각해보자. 이 프로퍼티는 다음과 같은 Level 이늄 타입이다.
- 스프링은 당연히 Level 타입을 알지 못한다. 따라서 파라미터를 직접 매핑할 수 있는 방법은 없다.
- Level의 각 요소에는 기본적으로 다음과 같이 DB에 저장할 때 사용할 값을 지정해뒀다.
- 이 값에 대응되는 Level 오브젝트를 가져오는 valueOf() 스태틱 메소드와 Level 오브젝트에서 값을 읽어오는 intValue() 메소드도 함께 제공된다.
  ```java
  public enum Level {
    GOLD(3, null), SILVER(2, GOLD), BASIC(1, SILVER);
    ...
    public int intValue() {
      return value;
    }
  
    public static Level valueOf(int value) {
      swtich(value) {
        case 1: return BASIC;
        case 2: return SILVER;
        case 3: return GOLD;
        default: throw new AssertionError("Unknown value: " + value);
      }
    }
  }
  ```
- 이 두 개의 메소드를 이용하면 1,2,3 같은 값과 Level 오브젝트 사이에 변환이 가능하다.
- 1,2,3은 물론 문자로 표현되어 있어도 상관없다. 간단히 숫자로 바꿔줄 수 있기 때문이다.
- Level을 지원하는 프로퍼티 에디터를 만들어서 다음과 같은 컨트롤러 메소드가 /user/search?level=1에 대해 정상적으로 동작하도록 만들어보자.
  ```java
  @RequestMapping("/user/search")
  search(@RequestParam Level level) { ... }
  ```
- Level에 대한 프로퍼티 에디터 없이 URL에 level=1이라고 파라미터를 줘서 위의 메소드를 실행시키면 어떻게 될까?
- 이때는 String 타입을 Level로 변환할 수 없어서 발생하는 ConversionNotSupportedException 예외 때문에 HTTP 500 에러를 만나게 될 것이다.
- 이제 Level 타입에 대한 프로퍼티 에디터를 만들어보자.
- PropertyEditor에서 변환을 위해 사용되는 메소드는 총 네 가지가 있다.
- HTTP 요청 파라미터와 같은 문자열 스트링 타입으로 서블릿에서 가져온다.
  스프링이 이 스트링 타입의 문자열을 변경할 타입의 오브젝트로 만들 때는 프로퍼티 에디터의 두 개의 메소드가 사용된다.
- 먼저 setAsText() 메소드를 이용해 스트링 타입의 문자열을 넣고 getValue()로 변환된 오브젝트를 가져온다.
- 반대로 오브젝트를 다시 문자열로 바꿀때는 setValue()로 오브젝트를 넣고 getAsText() 메소드로 변환된 문자열을 가져온다.
- 여기서 getValue()와 setValue()는 오브젝트를 저장하고 가져올 때 사용하는 것이므로 손댈 것 없고, 구현해줘야 할 메소드는 바로 setAsText()와 getAsText() 두 가지다.
- 다음은 이 네 개의 메소드를 통해 프로퍼티 에디터가 문자열로 된 값을 특정 오브젝트로 변환하거나 그 반대로 변환하는 과정을 보여준다.
  ![프로퍼티 에디터의 동작원리](images/PropertyEditor%20Process.jpg)
- 프로퍼티 데이터를 만들때는 PropertyEditor 인터페이스를 직접 구현하기 보다는
  기본구현이 되어 있는 PropertyEditorSupport 클래스를 상속해서 필요한 메소드만 오버라이드 해주는 편이 낫다.
- setAsText()에서는 스트링 타입의 파라미터를 오브젝트로 변환해서 넣어주고, getAsText()에서는 그 반대로 변환해주는 코드를 작성하면 된다.
- 다음은 문자열과 Level 타입 오브젝트의 변환을 담당하는 프로퍼티 에디터의 구현 코드와 테스트 코드다.
  ```java
  public class LevelPropertyEditor extends PropertyEditorSupport {
    public String getAsText() {
        return String.valueOf(((Level)this.getValue()).intValue());
    }

    public void setAsText(String text) throws IllegalArgumentException {
        this.setValue(Level.valueOf(Integer.parseInt(text.trim())));
    }
  }

  @Test
  public void levelPropertyEditor() {
    LevelPropertyEditor levelEditor = new LevelPropertyEditor();
    
    levelEditor.setValue(Level.BASIC);
    assertThat(levelEditor.getAsText(), is("1"));
    
    levelEditor.setAsText("3");
    assertThat((Level)levelEditor.getValue(), is(Level.GOLD));
  }
  ```

## @InitBinder
- @MVC에는 스프링 컨테이너에 정의된 디폴트 프로퍼티 에디터만 등록되어 있다.
  여기에 LevelPropertyEditor를 추가해서 Level 타입의 변환이 필요할 때 사용되도록 만들어야 한다.
- 먼저 컨트롤러 메소드에서 바인딩이 어떻게 일어나는지 살펴보자.
  @Controller 메소드를 호출해줄 책임이 있는 AnnotationMethodHandlerAdapter는 @RequestParam이나 @ModelAttribute,
  @PathVariable 등처럼 HTTP 요청을 파라미터 변수에 바인딩해주는 작업이 필요한 애노테이션을 만나면 먼저 WebDataBinder를 만든다.
- WebDataBinder는 여러가지 기능을 제공하는데, 그중에 HTTP요청으로부터 가져온 문자열을 파라미터 타입의 오브젝트로 변환하는 기능도 포함되어 있다.
- 물론 이 변환 작업은 프로퍼티 에디터를 이용한다. 따라서 개발자가 직접 만든 커스텀 프로퍼티 에디터를 @RequestParam과 같은 메소드 파라미터 바인딩에
  적용하려면 바로 이 WebDataBinding에 프로퍼티 에디터를 직접 등록해줘야 한다.
- 문제는 WebDataBinder는 AnnotationMethodHandlerAdapter가 복잡한 과정을 통해 메소드 파라미터와 애노테이션 등을 분석하고 바인딩을
  진행하는 과정 내부에서 만들어지기 때문에 외부로 직접 노출되지 않는다는 점이다.
- 스프링이 특별히 제공하는 WebDataBinder 초기화 메소드를 이용해야 한다.
- 컨트롤러 클래스에 다음과 같이 @InitBinder라는 애노테이션이 부여되어 있고, 파라미터로 WebDataBinder 타입이 정의된 메소드를 하나 생성한다.
- 그리고 파라미터로 전달되는 WebDataBinder 오브젝트의 registerCustomEditor() 메소드를 호출해서 LevelPropertyEditor 오브젝트를 등록해주자.
  ```java
  @InitBinder
  public void initBinder(WebDataBinder dataBinder) {
    dataBinder.registerCustomEditor(Level.class, new LevelPropertyEditor());
  }
  ```
- @InitBinder가 붙은 initBinder() 메소드는 메소드 파라미터를 바인딩하기 전에 자동으로 호출한다.
- 그래서 스프링의 디폴트 프로퍼티 에디터만 갖고 있는 WebDataBinder에 커스텀 프로퍼티 에디터를 추가할 수 있는 기회를 제공해준다.
- registerCustomEditor()는 프로퍼티 에디터를 적용할 타입과 프로퍼티 에디터 오브젝트를 넣어서 WebDataBinder에 새로운 프로퍼티 에디터를 추가해주는 메소드다.
- 다음은 WebDataBinder의 사용방법을 테스트하는 코드다.
  ```java
  WebDataBinder dataBinder = new WebDataBinder(null);
  dataBinder.registerCustomEditor(Level.class, new LevelPropertyEditor());
  assertThat(dataBinder.convertIfNecessary("1", Level.class)), is(Level.BASIC); 
  ```
- 바인더 오브젝트를 만들고 추가로 프로퍼티 에디터를 등록해주면 타입 변환 메소드를 이용할 수 있다.
- 물론 WebDataBinder를 코드에서 직접 만들어 수동으로 바인딩할 필요는 없다.
  스프링이 컨트롤러 메소드의 파라미터 모델 프로퍼티를 바인딩할 때 알아서 초기화해둔 WebDataBinder를 이용하기 때문인다.
- 하지만 커스텀 프로퍼티 에디터를 추가하는 것은 컨트롤러 코드를 만드는 개발자의 몫이다.
- 따라서 @InitBinder가 붙은 메소드를 적절히 이용해서 필요한 프로퍼티 에디터를 추가해줘야 한다.
- @InitBinder에 의해 등록된 커스텀 에디터는 같은 컨트롤러의 메소드에서 HTTP 요청을 바인딩하는 모든 작업에 적용된다.
- WebDataBinder의 바인딩 적용 대상은 @RequestParam 파라미터, @CookieValue 파라미터, @RequestHeader 파라미터,
  @PathVariable 파라미터, @ModelAttribute 파라미터의 프로퍼티다.
- 따라서 이런 요청 정보는 프로퍼티 에디터를 통해 적절한 타입 변환을 기대할 수 있다면 String 대신 다른 타입으로 메소드 파라미터를 선언해두는 게 좋다.
- 컨트롤러 메소드 내에서 지저분한 변환 과정을 다시 거칠 필요가 없기 때문이다.
- WebDataBinder에 커스텀 프로퍼티 에디터를 등록하는 방법은 다시 두 가지로 구분해볼 수 있다.

### 특정 타입에 무조건 적용되는 프로퍼티 에디터 등록
- 위의 예처럼 적용 타입과 프로퍼티 에디터 두 개를 파라미터로 받는 registerCustomEditor()를 사용해 프로퍼티 에디터를 등록했다면,
  해당 타입을 가진 바인딩 대상이 나오면 항상 프로퍼티 에디터가 적용된다.
- 디폴트 프로퍼티 에디터에서는 지원하지 않는 타입이라면 기본적으로 이 방식을 사용하는 것이 적절하다.

### 특정 이름의 프로퍼티에만 적용되는 프로퍼티 에디터 등록
- 두 번째 등록 방법은 타입과 프로퍼티 에디터 오브젝트 외에, 추가로 적용할 프로퍼티 이름을 지정하는 것이다.
- 따라서 같은 타입이지만 프로퍼티 이름이 일치하지 않는 경우에는 등록한 커스텀 프로퍼티 에디터가 적용되지 않는다.
- 프로퍼티 이름이 필요하므로 @RequestParam과 같은 단일 파라미터 바인딩에는 적용되지 않는다.
- 모델 오브젝트 안에 같은 타입의 프로퍼티가 여러 개 있다고 해도, 그중에서 프로퍼티 에디터를 등록할 때
  지정한 이름과 일치하는 프로퍼티에만 프로퍼티 에디터가 적용된다.
- 그렇다면 이렇게 프로퍼티 이름까지 직접 지정해서 제한적으로 커스텀 프로퍼티 에디터를 적용해야 할 경우는 언제일까?
  또, 프로퍼티 이름이 일치하지 않아서 커스텀 프로퍼티 에디터가 적용되지 않는 파라미터가 있다면 그 파라미터 바인딩 작업에서는 예외가 발생하지 않을까?
- 이름이 포함된 프로퍼티 에디터의 등록은 이미 프로퍼티 에디터가 존재하는 경우에 사용하기 적합하다.
- WebDataBinder는 바인딩 작업 시 커스텀 프로퍼티 에디터를 먼저 적용해보고 적절한 프로퍼티 에디터가 없으면 그때 디폴트 프로퍼티 에디터를 사용한다.
  즉, 커스텀 프로퍼티 에디터가 우선순위를 갖는다.
- 이미 스프링의 디폴트 프로퍼티 에디터에서 지원하는 int 타입에 대해 커스텀 프로퍼티 에디터를 만든다고 생각해보자.
- 단순히 문자열을 int 타입으로 변환하는 것이 전부가 아니라 부가적인 조건을 부여해줄 필요가 있기 때문이다.
- 다음은 int 타입을 지원하는 커스텀 프로퍼티 에디터의 예다.
  이름 그대로 최소값과 최대값을 지정할 수 있고, 이 범위에 포함되지 않는 값이 있으면 강제로 최소값이나 최대값으로 변경한다.
  ```java
  public class MinMaxPropertyEditor extends PropertyEditorSupport {
    int min;
    int max;
  
    public MinMaxPropertyEditor(int min, int max) {
      this.min = min;
      this.max = max;
    }
  
    @Override
    public String getAsText() {
      return String.valueOf((Integer)this.getValue());
    }

    @Override
    public void setAsText(String text) throws IllegalArgumentException {
      Integer val = Integer.parseInt(text);
      if(val < min) {
        val = min;
      }
      else if(val > max) {
        val = max;
      }
      setValue(val);
    }
  }
  ```
- 다음과 같이 두 개의 int 타입을 갖는 오브젝트가 있다.
  ```java
  public class Member {
    int id;
    int age;
    // 수정자, 접근자 코드 생략
  }
  ```
- 컨트롤러 메소드는 다음과 같이 Member 타입의 프로퍼티에 HTTP 요청 파라미터를 바인딩해주도록 @ModelAttribute로 선언한다.
  ```java
  @RequestMapping("/add")
  public void add(@ModelAttribute Member member) { ... }
  ```
- 별도의 프로퍼티 에디터를 등록하지 않았다고 하면, URL이 /add?id=1000&age=1000 이라고 주어졌을때 디폴트로 등록된 int 타입의
  프로퍼티 에디터가 동작해서 Member 오브젝트의 id, age에 각각 1000이라는 값을 넣어줄 것이다.
- 그런데 age는 단순 일련번호인 id와 달리 사람의 나이를 나타내므로 int 타입이긴 하지만 적절한 범위 안의 값만 사용해야 한다.
  그래서 int 타입에 대해 MinMaxPropertyEditor를 등록해버리면 id에도 적용되는 문제가 발생한다.
- 커스텀 프로퍼티 에디터는 디폴트 프로퍼티 에디터보다 우선하기 때문에 모든 int 타입의 파라미터에 다 MinMaxPropertyEditor가 적용된다.
- 그래서 MinMaxPropertyEditor는 int 타입의 프로퍼티 중에서도 이름이 age인 경우에만 적용하도록 만들어줘야 한다.
- 이를 위해 다음과 같이 프로퍼티 이름을 지정하는 커스텀 프로퍼티 에디터 등록 방식을 사용해야 한다.
  ```java
  @InitBinder
  public void initBinder(WebDataBinder dataBinder) {
    dataBinder.registerCustomEditor(int.class, "age", new MinMaxPropertyEditor(0, 200));
  }
  ```
- 이렇게 해주면 MinMaxPropertyEditor는 Member 오브젝트의 int 타입 프로퍼티 중에서 age라는 이름의 프로퍼티에만 적용된다.
- id 프로퍼티는 MinMaxPropertyEditor의 적용 대상이 되지 않으므로 디폴트로 등록된 int 타입의 프로퍼티 에디터에 의해 정수 값으로 변환해줄 것이다.
- 따라서 /add?id=1000&age=1000 URL이 주어졌을때 바인딩을 거쳐서 컨트롤러 메소드가 전달받는 member 오브젝트에는
  id 프로퍼티에 1000, age 프로퍼티에 최대값으로 설정한 200이 들어간다.
- @InitBinder 메소드의 파라미터에는 WebDataBinder 외에 WebRequest도 사용할 수 있다.
- WebRequest는 HttpServletRequest에 들어있는 거의 모든 HTTP 요청정보를 담고 있다.
  따라서 HTTP 요청에 따라 다른 방식으로 WebDataBinder에 프로퍼티 에디터 등을 설정하는데 활용할 수 있다.

### [학습테스트 - MinMaxPropertyEditor](/src/main/java/com/hello4/controller/Hello4Controller.java)

## WebBindingInitializer
- @InitBinder 메소드에서 WebDataBinder에 추가한 커스텀 프로퍼티 에디터는 메소드가 있는 컨트롤러 클래스 안에서만 동작한다.
- Level 타입의 바인딩이 애플리케이션 전반에 걸쳐 폭넓게 필요한 경우라면, @InitBinder 메소드를 컨트롤러마다 추가하고 LevelPropertyEditor를
  등록하는 코드를 반복적으로 추가해줘야 한다.
- 같은 컨트롤러 내에서는 모든 컨트롤러 메소드에 한 번에 적용되긴 하지만, 컨트롤러 클래스가 다를경우 다시 등록해주는 코드를 넣어야 한다면 매우 번거로운 일이다.
- 그래서 이렇게 모든 컨트롤러에 적용해도 될 만큼 많은 곳에서 필요한 프로퍼티 에디터라면 등록하는 방법을 달리해서 한 번에 모든 컨트롤러에 적용하는 편이 좋다.
- 이런 용도로 만들어진 WebBindingInitializer를 이용하면 된다.
- 먼저 WebBindingInitializer 인터페이스를 구현해서 다음과 같은 클래스를 작성한다. 구현할 메소드는 @InitBinder를 적용했던 메소드와 비슷하다.
- WebDataBinder를 전달받아서 커스텀 프로퍼티 에디터를 추가하는 코드를 넣는다.
  ```java
  public class MyWebBindingInitializer implements WebBindingIntializer {
    public void initBinder(WebDataBinder binder, WebRquest request) {
      binder.registerCustomEditor(Level.class, new LevelPropertyEditor());
    }
  }
  ```
- WebBindingInitializer를 구현해서 만든 클래스를 빈으로 등록하고 @Controller를 담당하는 어댑터 핸들러인
  AnnotationMethodHandlerAdapter의 webBindingInitializer 프로퍼티에 DI 해준다.
- 이 프로퍼티 설정을 위해서는 AnnotationMethodHandlerAdapter도 빈으로 직접 등록해야 한다.
- WebBindingInitializer는 다른 곳에서 참조할 일은 없으므로 다음과 같이 내부 빈 설정 방식을 이용해 등록해도 좋다.
  ```xml
  <bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMehtodHandlerAdapter">
    <property name="webBindingInitializer">
      <bean class="springbook...MyWebBindingInitializer" />
    </property>
  </bean>
  ```
- 이렇게 AnnotationMethodHandlerAdapter 레벨에 바인딩을 초기화하는 빈을 등록해주면 이 빈의 initBinder() 메소드는
  모든 컨트롤러의 모든 바인딩 작업에 일괄 적용된다.
- 따라서 LevelPropertyEditor를 매번 @InitBinder 메소드를 통해 컨트롤러마다 등록해줄 필요가 없게 된다.
- 물론 Level 타입의 바인딩이 필요 없는 컨트롤러에도 매번 적용되는 낭비가 있기는 하다.
  하지만 프로퍼티 에디터는 워낙 간단한 클래스이므로 자주 생성되도 별문제가 되지 않는다.
- 적절한 기준을 정해두고 일정 비율 이상의 컨트롤러에서 필요로 하는 커스텀 프로퍼티 에디터는 WebBindingInitializer를 이용해 등록하는 방법을 검토해보자.

## 프로토타입 빈 프로퍼티 에디터
- 지금까지 등장한 모든 커스텀 프로퍼티 에디터 등록 코드를 잘 살펴보면, 모든 메소드에서 매번 new 키워드를 사용해 프로퍼티 에디터 오브젝트를 새로 만들고 있음을 알 수 있다.
- @InitBinder 메소드나 WebBindingInitializer 메소드에서도 마찬가지다.
  프로퍼티 바인딩을 할 때마다 매번 새로운 프로퍼티 에디터 오브젝트를 만들어 사용한다는 것이다.